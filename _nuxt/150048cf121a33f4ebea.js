(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{296:function(n){n.exports=JSON.parse('{"name":"sample01","title":"What is Lorem Ipsum?","tags":["タグ1"],"category":"その他","created_at":"2019-02-16 00:08:00","updated_at":"2019-02-16 00:00:00","bodyContent":"# TEST MESSAGE\\n\\n- TEST\\n  複素数体であれば、任意の CM-タイプの A は、実際、数体である定義体（英語版）(field of definition)を持っている。自己準同型環の可能なタイプは、対合（ロサチの対合（英語版）(Rosati involution）をもつ環として既に分類されていて、CM-タイプのアーベル多様体の分類を導き出す。楕円曲線と同じような方法で CM-タイプの多様体を構成するには、Cd の中の格子 Λ から始め、アーベル多様体のリーマンの関係式（英語版）(Riemann relations)を考えに入れる必要がある。 CM-タイプ(CM-type)は、単位元での A の正則接空間上にある EndQ(A) の（最大）可換部分環 L の作用を記述したものである。単純な種類のスペクトル理論が適応され、L が固有ベクトルの基底を通して作用することを示すことができる。言い換えると、L は A の正則ベクトル場の上の対角行列を通した作用を持っている。L 自体がある複数の体の積というよりも数体であるという単純な場合には、CM-タイプは L の複素埋め込み（英語版）(complex embedding)のリストである。複素共役をなすペアとして、2d 個の複素埋め込みがあり、CM-タイプは各々のペアのから一つを選択する。そのような CM-タイプの全てが実現されることが知られている。\\n\\n```js\\nconst posts = await client.getEntries({\\n  content_type: process.env.CTF_BLOG_POST_TYPE_ID,\\n  \'fields.slug\': slug\\n})\\n```\\n\\n```rb\\n$foo = 5;\\nclass InstTest\\n  def set_foo(n)\\n    @foo = n\\n  end\\n  def set_bar(n)\\n    @bar = n\\n  end\\nend\\n```\\n\\n```ruby\\nclass Api::V1::ArticlesController < ApplicationController\\n  before_action :set_article, only: [:show, :update, :destroy]\\n\\n  PER = 8\\n\\n  # GET /articles\\n  def index\\n    @articles = Article.select(\'id, title, tag, created_at\').page(params[:page]).per(PER)\\n    render json: @articles\\n  end\\n\\n  # GET /articles/1\\n  def show\\n    render json: @article\\n  end\\n\\n  # GET /articles\\n  def create\\n    @article = Article.new(article_params)\\n\\n    if @article.save\\n      render json: @article, status: :created, location: @user\\n    else\\n      render json: @article.errors, status: :unprocessable_entry\\n    end\\n  end\\n\\n  # PUT /articles/1\\n  def update\\n    if @article.update(article_params)\\n      render json: @article\\n    else\\n      render json: @article.errors, status: :unprocessable_entry\\n    end\\n  end\\n\\n  # DELETE /articles/1\\n  def destroy\\n    @articles.destroy\\n  end\\n\\n  private\\n\\n  def set_article\\n    @article = Article.find(params[:id])\\n  end\\n\\n  def article_params\\n    params.fetch(:article, {})\\n  end\\nend\\n```","bodyHtml":"<h1>TEST MESSAGE</h1>\\n<ul>\\n<li>TEST\\n複素数体であれば、任意の CM-タイプの A は、実際、数体である定義体（英語版）(field of definition)を持っている。自己準同型環の可能なタイプは、対合（ロサチの対合（英語版）(Rosati involution）をもつ環として既に分類されていて、CM-タイプのアーベル多様体の分類を導き出す。楕円曲線と同じような方法で CM-タイプの多様体を構成するには、Cd の中の格子 Λ から始め、アーベル多様体のリーマンの関係式（英語版）(Riemann relations)を考えに入れる必要がある。 CM-タイプ(CM-type)は、単位元での A の正則接空間上にある EndQ(A) の（最大）可換部分環 L の作用を記述したものである。単純な種類のスペクトル理論が適応され、L が固有ベクトルの基底を通して作用することを示すことができる。言い換えると、L は A の正則ベクトル場の上の対角行列を通した作用を持っている。L 自体がある複数の体の積というよりも数体であるという単純な場合には、CM-タイプは L の複素埋め込み（英語版）(complex embedding)のリストである。複素共役をなすペアとして、2d 個の複素埋め込みがあり、CM-タイプは各々のペアのから一つを選択する。そのような CM-タイプの全てが実現されることが知られている。</li>\\n</ul>\\n<pre><code class=\\"hljs\\"><span class=\\"hljs-keyword\\">const</span> posts = <span class=\\"hljs-keyword\\">await</span> client.getEntries({\\n  <span class=\\"hljs-attr\\">content_type</span>: process.env.CTF_BLOG_POST_TYPE_ID,\\n  <span class=\\"hljs-string\\">\'fields.slug\'</span>: slug\\n})</code></pre><pre><code class=\\"hljs\\">$foo = <span class=\\"hljs-number\\">5</span>;\\n<span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">InstTest</span></span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">set_foo</span><span class=\\"hljs-params\\">(n)</span></span>\\n    @foo = n\\n  <span class=\\"hljs-keyword\\">end</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">set_bar</span><span class=\\"hljs-params\\">(n)</span></span>\\n    @bar = n\\n  <span class=\\"hljs-keyword\\">end</span>\\n<span class=\\"hljs-keyword\\">end</span></code></pre><pre><code class=\\"hljs\\"><span class=\\"hljs-class\\"><span class=\\"hljs-keyword\\">class</span> <span class=\\"hljs-title\\">Api::V1::ArticlesController</span> &lt; ApplicationController</span>\\n  before_action <span class=\\"hljs-symbol\\">:set_article</span>, <span class=\\"hljs-symbol\\">only:</span> [<span class=\\"hljs-symbol\\">:show</span>, <span class=\\"hljs-symbol\\">:update</span>, <span class=\\"hljs-symbol\\">:destroy</span>]\\n\\n  PER = <span class=\\"hljs-number\\">8</span>\\n\\n  <span class=\\"hljs-comment\\"># GET /articles</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">index</span></span>\\n    @articles = Article.select(<span class=\\"hljs-string\\">\'id, title, tag, created_at\'</span>).page(params[<span class=\\"hljs-symbol\\">:page</span>]).per(PER)\\n    render <span class=\\"hljs-symbol\\">json:</span> @articles\\n  <span class=\\"hljs-keyword\\">end</span>\\n\\n  <span class=\\"hljs-comment\\"># GET /articles/1</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">show</span></span>\\n    render <span class=\\"hljs-symbol\\">json:</span> @article\\n  <span class=\\"hljs-keyword\\">end</span>\\n\\n  <span class=\\"hljs-comment\\"># GET /articles</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">create</span></span>\\n    @article = Article.new(article_params)\\n\\n    <span class=\\"hljs-keyword\\">if</span> @article.save\\n      render <span class=\\"hljs-symbol\\">json:</span> @article, <span class=\\"hljs-symbol\\">status:</span> <span class=\\"hljs-symbol\\">:created</span>, <span class=\\"hljs-symbol\\">location:</span> @user\\n    <span class=\\"hljs-keyword\\">else</span>\\n      render <span class=\\"hljs-symbol\\">json:</span> @article.errors, <span class=\\"hljs-symbol\\">status:</span> <span class=\\"hljs-symbol\\">:unprocessable_entry</span>\\n    <span class=\\"hljs-keyword\\">end</span>\\n  <span class=\\"hljs-keyword\\">end</span>\\n\\n  <span class=\\"hljs-comment\\"># PUT /articles/1</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">update</span></span>\\n    <span class=\\"hljs-keyword\\">if</span> @article.update(article_params)\\n      render <span class=\\"hljs-symbol\\">json:</span> @article\\n    <span class=\\"hljs-keyword\\">else</span>\\n      render <span class=\\"hljs-symbol\\">json:</span> @article.errors, <span class=\\"hljs-symbol\\">status:</span> <span class=\\"hljs-symbol\\">:unprocessable_entry</span>\\n    <span class=\\"hljs-keyword\\">end</span>\\n  <span class=\\"hljs-keyword\\">end</span>\\n\\n  <span class=\\"hljs-comment\\"># DELETE /articles/1</span>\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">destroy</span></span>\\n    @articles.destroy\\n  <span class=\\"hljs-keyword\\">end</span>\\n\\n  private\\n\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">set_article</span></span>\\n    @article = Article.find(params[<span class=\\"hljs-symbol\\">:id</span>])\\n  <span class=\\"hljs-keyword\\">end</span>\\n\\n  <span class=\\"hljs-function\\"><span class=\\"hljs-keyword\\">def</span> <span class=\\"hljs-title\\">article_params</span></span>\\n    params.fetch(<span class=\\"hljs-symbol\\">:article</span>, {})\\n  <span class=\\"hljs-keyword\\">end</span>\\n<span class=\\"hljs-keyword\\">end</span></code></pre>","preview":"TEST MESSAGE\\n\\nTEST\\n  複素数体であれば、任意の CM-タイプの A は、実際、数体である定義体（英語版）(field of definition)を持っている。自己準同型環の可能なタイプは、対合（ロサチの対合（英語版）(Rosati","dir":"contents/json","base":"sample01.json","ext":".json","sourceBase":"sample01.md","sourceExt":".md"}')}}]);